###  Flowable 网关
网关用来控制流程的流向

### 一、排他网关
* 特点：对所有分支的条件进行判断，选择第一个条件计算为true的分支进行后续环节
* 注意
  * 当没有设置条件时，默认分支判断结果为true
  * 当有多个分支结果为true时，会选择XML中最先定义的分支继续流程
  * 如果没有可选的分支，会抛出异常

![](https://fgq233.github.io/imgs/workflow/flow08.png)

```
Map<String, Object> var = new HashMap<>();
var.put("num", 2);
taskService.complete("task1_id_......", var);
```

* 如图：两个分支条件分别是`${num < 3}、${num >= 3}`
* 当员工请假分支在完成任务时，传入网关判断需要的变量，进行结果为`true`的后续环节


### 二、并行网关
* 功能
  * `fork分支`：将流程分成多条分支，多条分支并行执行，互不影响
  * `join汇聚`：将多条分支汇聚成一条分支，所有到达的进行等待，直到全部到达，流程才会通过并行网关
* 注意：
  * **一个并行网关**可以只fork分支，可以只join汇聚，也可以两个功能都有
  * 并行网关不会解析条件，即使定义了条件，也会忽略

![](https://fgq233.github.io/imgs/workflow/flow09.png)


* 如图流程，当第一个环节完成后，通过并行网关，产生了 2 个分支
  * 任务表`act_ru_task`产生2条记录，2条记录的执行实例`execution_id`不一样
  * 然后在`act_ru_execution`中同时有三条记录，一个任务对应的有两个执行实例
* 当2个分支任务都完成后，才会通过第二个并行网关，进行下一环节



### 三、包容网关
* 包括网关类似`排他网关`和`并行网关`的结合体 主要的区别是包含网关可以选择多于一条顺序流，这和并行网关一样。
  * 判断：和排他网关一样，可以在连线上定义条件，结果为 true 则进入该分支，不设置条件默认为true
  * fork分支：将流程分成多条分支，多条分支并行执行，互不影响
  * join汇聚：将多条分支汇聚成一条分支，所有到达包容网关分支在此等待，直到所有进入的分支都到达以后，流程就会通过包容网关

![](https://fgq233.github.io/imgs/workflow/flow10.png)


```
Map<String, Object> var = new HashMap<>();
var.put("money", 888);
taskService.complete("task1_id_......", var);
```

* 如图：3个分支条件分别是`${money < 1000}、无、${num >= 1000}`
* 当员工采购申请在完成任务时，传入变量money为888，则组长审批、部门经理审批环节产生
  * 任务表`act_ru_task`产生2条记录，2条记录的执行实例`execution_id`不一样
  * 然后在`act_ru_execution`中同时有三条记录，一个任务对应的有两个执行实例
* 当2个分支任务都完成后，才会通过第二个包容网关，进行下一环节 - 总经理审批


### 四、事件网关
事件网关允许根据事件判断流向
* 网关的每个外出顺序流都要连接到一个中间捕获事件。
* 当流程到达一个基于事件网关，网关会进入等待状态：会暂停执行
* 与此同时，会为每个外出顺序流创建相对的事件订阅

* 事件网关的外出顺序流和普通顺序流不同，这些顺序流不会真的"执行"， 
相反它们让流程引擎去决定执行到事件网关的流程需要订阅哪些事件，要考虑以下条件：
* 1. 事件网关必须有两条或以上外出顺序流；
* 2. 事件网关后，只能使用intermediateCatchEvent类型（activiti不支持基于事件网关后连接ReceiveTask）
* 3. 连接到事件网关的中间捕获事件必须只有一个入口顺序流。 
